{-# LANGUAGE OverloadedLists     #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE QuasiQuotes         #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Dalek.ReplSpec (spec) where

import           Dalek.SpecUtils

import           Data.String.Interpolate (i)

import qualified Dhall.Core              as Dh
import           Dhall.TypeCheck         (X)

import           Dalek.Repl

normXLetBind :: LetBind X -> LetBind X
normXLetBind = normalizeLetBindWith xNormalizer

normX :: Dh.Expr s X -> Dh.Expr s X
normX = Dh.normalizeWith xNormalizer

emptyScope :: LetScope X
emptyScope = mempty

spec :: Spec
spec = do
  describe ":let" $ do
    it "should parse un-annotated :let without parens" $ do
      (name, letBind) <- parsed' (letBindParser xParser) [i|
        :let x = +2
      |]
      name `shouldBe` "x"
      normXLetBind letBind `shouldBe` LetBind Nothing (Dh.NaturalLit 2)
    it "should parse un-annotated :let with parens" $ do
      pure () :: IO ()
    it "should parse annotated :let without parens" $ do
      (name, letBind) <- parsed' (letBindParser xParser) [i|
        :let x : Natural = +2
      |]
      name `shouldBe` "x"
      normXLetBind letBind `shouldBe` LetBind (Just Dh.Natural) (Dh.NaturalLit 2)
    it "should parse annotated :let with parens" $ do
      pure () :: IO ()
  describe "LetScope" $ do
    -- Testing bindLet and unbindLet in isolation is a little annoying.
    -- It'll be easier to test them by using them & normalizing a dhall program
    -- generated by mkLet. Or maybe use lookup to inspect the LetScope for
    -- isolated tests. Both tests will be good.
    it "unbindLet should undo bindLet" $ do
      let oneBind = bindLet "a" (LetBind Nothing (Dh.NaturalLit 2)) emptyScope
      unbindLet "a" oneBind `shouldBe` emptyScope

      let twoBinds = bindLet "a" (LetBind Nothing (Dh.TextLit "x")) oneBind
      unbindLet "a" twoBinds `shouldBe` oneBind
    it "mkLet should be id with no scope" $ do
      let expr = Dh.NaturalLit 2
      mkLet emptyScope expr `shouldBe` expr
    it "mkLet should normalize as expected" $ do
      let expr = Dh.Var "x"
      let scope = bindLet "x" (LetBind Nothing (Dh.NaturalLit 2)) emptyScope
      normX (mkLet scope expr) `shouldBe` Dh.NaturalLit 2
    it "bindLet should shadow correctly" $ do
      let expr = Dh.Var "x"
      let scope = bindLet "x" (LetBind Nothing (Dh.TextLit "x"))
                $ bindLet "x" (LetBind Nothing (Dh.NaturalLit 2)) emptyScope
      normX (mkLet scope expr) `shouldBe` Dh.TextLit "x"
    it "unbindLet should unshadow" $ do
      let expr = Dh.Var "x"
      let scope = unbindLet "x"
                $ bindLet "x" (LetBind Nothing (Dh.TextLit "x"))
                $ bindLet "x" (LetBind Nothing (Dh.NaturalLit 2)) emptyScope
      normX (mkLet scope expr) `shouldBe` Dh.NaturalLit 2
